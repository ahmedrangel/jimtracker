<script setup lang="ts">
import { CategoryScale, Chart as ChartJS, Filler, Legend, LineElement, LinearScale, PointElement, Title, Tooltip } from "chart.js";
import { Line } from "vue-chartjs";
import { format } from "date-fns";
import { es } from "date-fns/locale";

const { data: champions } = await useFetch("/api/champions");

const props = defineProps<{
  history?: History[];
}>();

ChartJS.register(
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend,
  Filler
);

const normalizeTier = {
  IRON: "Hierro",
  BRONZE: "Bronce",
  SILVER: "Plata",
  GOLD: "Oro",
  PLATINUM: "Platino",
  EMERALD: "Esmeralda",
  DIAMOND: "Diamante",
  MASTER: "Maestro",
  GRANDMASTER: "Gran Maestro",
  CHALLENGER: "Retador"
};

const LEAGUE_TIERS = [
  { name: "Hierro", divisions: ["IV", "III", "II", "I"], color: "#6B4E24" },
  { name: "Bronce", divisions: ["IV", "III", "II", "I"], color: "#A0522D" },
  { name: "Plata", divisions: ["IV", "III", "II", "I"], color: "#C0C0C0" },
  { name: "Oro", divisions: ["IV", "III", "II", "I"], color: "#FFD700" },
  { name: "Platino", divisions: ["IV", "III", "II", "I"], color: "#40E0D0" },
  { name: "Esmeralda", divisions: ["IV", "III", "II", "I"], color: "#50C878" },
  { name: "Diamante", divisions: ["IV", "III", "II", "I"], color: "#B9F2FF" },
  { name: "Maestro", divisions: [""], color: "#9932CC" },
  { name: "Gran Maestro", divisions: [""], color: "#DC143C" },
  { name: "Retador", divisions: [""], color: "#F7931E" }
];

// Convertir rango y LP a valor numérico para el gráfico
const rankToValue = (tier: string, division: string, lp: number): number => {
  const tierIndex = LEAGUE_TIERS.findIndex(t => t.name.toLowerCase() === tier.toLowerCase());
  if (tierIndex === -1) return 0;

  let baseValue = tierIndex * 400; // 400 puntos por tier

  if (tier.toLowerCase() === "maestro" || tier.toLowerCase() === "gran maestro" || tier.toLowerCase() === "retador") {
    // Para rangos sin divisiones, usar directamente los LP
    baseValue += lp;
  }
  else {
    // Para rangos con divisiones
    const divisionValues = { IV: 0, III: 100, II: 200, I: 300 };
    baseValue += divisionValues[division as keyof typeof divisionValues] || 0;
    baseValue += lp; // Añadir LP dentro de la división
  }

  return baseValue;
};

// Convertir valor numérico de vuelta a rango
const valueToRank = (value: number): { tier: string, division: string, lp: number } => {
  const tierIndex = Math.floor(value / 400);
  const remainder = value % 400;

  if (tierIndex >= LEAGUE_TIERS.length) {
    return { tier: "Retador", division: "", lp: Math.min(remainder, 9999) };
  }

  const tier = LEAGUE_TIERS[tierIndex];

  if (!tier) {
    return { tier: "Hierro", division: "IV", lp: 0 };
  }

  if (tier.name === "Maestro" || tier.name === "Gran Maestro" || tier.name === "Retador") {
    return { tier: tier.name, division: "", lp: Math.min(remainder, 9999) };
  }

  const divisionIndex = Math.floor(remainder / 100);
  const lp = remainder % 100;
  const divisions = ["IV", "III", "II", "I"];

  return {
    tier: tier.name,
    division: divisions[divisionIndex] || "IV",
    lp: Math.min(lp, 100)
  };
};

// Función para procesar los datos reales de stats
const processRealStats = (stats: typeof props.history) => {
  if (!stats || stats.length === 0) {
    // No hay datos disponibles
    return { labels: [], data: [] };
  }

  // Ordenar stats por fecha para encontrar la primera partida
  const sortedStats = [...stats].sort((a, b) => a.date - b.date);
  const firstMatch = sortedStats[0]!;

  // Agrupar stats por día
  const statsByDay = new Map<string, typeof stats>();

  stats.forEach((stat) => {
    const date = new Date(stat.date);
    const dateKey = format(date, "yyyy-MM-dd");

    if (!statsByDay.has(dateKey)) {
      statsByDay.set(dateKey, []);
    }
    statsByDay.get(dateKey)!.push(stat);
  });

  // Encontrar el primer y último día con datos
  const daysWithData = Array.from(statsByDay.keys()).sort();
  if (daysWithData.length === 0) {
    return { labels: [], data: [] };
  }

  // Usar la fecha y hora exacta de la primera partida
  const firstMatchDate = new Date(firstMatch.date);
  const today = new Date();
  today.setHours(23, 59, 59, 999); // Asegurar que incluya todo el día de hoy

  // Generar solo los días desde el primer día con datos hasta hoy
  const chartLabels: string[] = [];
  const gameData: Array<{ value: number, matches: any[] }> = [];

  // Empezar desde la fecha de la primera partida, pero mantener la lógica de días completos
  let currentDate = new Date(firstMatchDate);
  currentDate.setHours(0, 0, 0, 0); // Empezar desde medianoche del día de la primera partida

  // Usar los datos de la primera partida como punto de referencia
  // Si la primera partida no tiene tier/division/lp, usar valores por defecto
  const firstTier = firstMatch.tier ? normalizeTier[firstMatch.tier.toUpperCase() as keyof typeof normalizeTier] : "Hierro";
  const firstDivision = firstMatch.division || "IV";
  const firstLp = firstMatch.lp || 0;
  let previousValue = rankToValue(firstTier, firstDivision, firstLp);

  while (currentDate <= today) {
    const dateKey = format(currentDate, "yyyy-MM-dd");
    const dayLabel = format(currentDate, "dd MMM", { locale: es });

    chartLabels.push(dayLabel);

    const dayStats = statsByDay.get(dateKey) || [];

    // Si hay stats para este día, usar el último LP/tier del día
    if (dayStats.length > 0) {
      // IMPORTANTE: Ordenar las partidas del día por fecha para obtener la última partida real
      const sortedDayStats = dayStats.sort((a, b) => a.date - b.date);
      const lastStat = sortedDayStats[sortedDayStats.length - 1]!;
      const tier = lastStat.tier ? normalizeTier[lastStat.tier.toUpperCase() as keyof typeof normalizeTier] : "Hierro";
      const division = lastStat.division || "IV";
      const lp = lastStat.lp || 0;

      const value = rankToValue(tier, division, lp);
      previousValue = value; // Actualizar el valor anterior

      // Convertir stats a formato de matches (también ordenados)
      const matches = sortedDayStats.map((stat) => {
        const matchDate = new Date(stat.date);
        const championName = champions.value?.find(c => c.id === String(stat.champion_id))?.name;
        return {
          champion: championName,
          score: {
            kills: stat.kills,
            deaths: stat.deaths,
            assists: stat.assists
          },
          lpChange: 0, // No tenemos el cambio exacto de LP por partida
          win: stat.result === 1,
          value: value,
          time: format(matchDate, "HH:mm"),
          isRemake: stat.is_remake === 1,
          isSurrender: stat.is_surrender === 1
        };
      });

      gameData.push({ value, matches });
    }
    else {
      // Si no hay datos para este día, usar el valor del día anterior
      gameData.push({ value: previousValue, matches: [] });
    }

    // Avanzar al siguiente día
    currentDate = new Date(currentDate);
    currentDate.setDate(currentDate.getDate() + 1);
  }

  return { labels: chartLabels, data: gameData };
};

// Calcular el rango visible basado en los datos
const calculateVisibleRange = (data: { value: number, matches: any[] }[]) => {
  // Si no hay datos, usar valores por defecto
  if (!data || data.length === 0) {
    return {
      min: 0,
      max: 400,
      tiers: LEAGUE_TIERS.slice(0, 1) // Solo mostrar Hierro
    };
  }

  const minValue = Math.min(...data.map(d => d.value));
  const maxValue = Math.max(...data.map(d => d.value));

  // Mostrar 2 divisiones adicionales arriba y abajo (200 puntos = 2 divisiones)
  const expandedMin = Math.max(0, minValue - 200);
  const expandedMax = Math.min(3999, maxValue + 200); // Cap at Challenger 999LP

  const minTier = Math.floor(expandedMin / 400);
  const maxTier = Math.floor(expandedMax / 400);

  return {
    min: expandedMin,
    max: expandedMax,
    tiers: LEAGUE_TIERS.slice(minTier, maxTier + 1)
  };
};

const { labels, data } = processRealStats(props.history);
const visibleRange = calculateVisibleRange(data);

const chartData = ref({
  labels,
  datasets: [
    {
      label: "Rango de LoL",
      data: data.map(d => d.value),
      borderColor: "#3B82F6",
      backgroundColor: "rgba(59, 130, 246, 0.1)",
      borderWidth: 3,
      fill: true,
      tension: 0.4,
      pointBackgroundColor: data.map((d) => {
        const rank = valueToRank(d.value);
        const tier = LEAGUE_TIERS.find(t => t.name === rank.tier);
        return tier?.color || "#3B82F6";
      }),
      pointBorderColor: "#ffffff",
      pointBorderWidth: 2,
      pointRadius: 5,
      pointHoverRadius: 8,
      pointHoverBorderColor: "#ffffff",
      pointHoverBorderWidth: 3
    }
  ]
});

const chartOptions = ref({
  responsive: true,
  maintainAspectRatio: false,
  interaction: {
    mode: "nearest",
    intersect: false
  },
  plugins: {
    legend: {
      display: false
    },
    tooltip: {
      position: "nearest",
      enabled: false, // Desactivar el tooltip por defecto
      external: (context: any) => {
        const { chart, tooltip } = context;
        let tooltipEl = chart.canvas.parentNode?.querySelector("#chartjs-tooltip");

        if (!tooltipEl) {
          tooltipEl = document.createElement("div");
          tooltipEl.id = "chartjs-tooltip";
          tooltipEl.innerHTML = "<table></table>";
          tooltipEl.style.opacity = 1;
          tooltipEl.style.position = "absolute";
          tooltipEl.style.transform = "translate(-50%, 0)";
          tooltipEl.style.transition = "all .3s ease";
          chart.canvas.parentNode?.appendChild(tooltipEl);
        }

        // Ocultar tooltip si no hay datos
        if (tooltip.opacity === 0) {
          tooltipEl.style.opacity = "0";
          return;
        }

        // Obtener los datos del punto
        if (tooltip.dataPoints && tooltip.dataPoints.length > 0) {
          const dataIndex = tooltip.dataPoints[0].dataIndex;
          const dayData = data[dataIndex];

          if (dayData && dayData.matches) {
            const currentRank = valueToRank(dayData.value);
            let rankDisplay = currentRank.tier;
            if (currentRank.division) {
              rankDisplay += ` ${currentRank.division}`;
            }
            rankDisplay += ` (${currentRank.lp} LP)`;

            // Calcular LP total ganado/perdido
            let totalChange = 0;
            if (dataIndex > 0 && dayData.matches.length > 0) {
              const previousDayFinalValue = data[dataIndex - 1]!.value;
              const currentDayFinalValue = dayData.value;
              totalChange = currentDayFinalValue - previousDayFinalValue;
            }

            const changeText = totalChange > 0 ? `+${Math.round(totalChange)}` : totalChange === 0 ? "0" : `${Math.round(totalChange)}`;
            const changeEmoji = totalChange > 0 ? "🟢" : totalChange < 0 ? "🔴" : "⚪";

            let innerHtml = `
              <div style="
                background: rgba(15, 23, 42, 0.95);
                border: 1px solid #3B82F6;
                border-radius: 8px;
                padding: 6px 0px;
                color: white;
                font-family: system-ui, -apple-system, sans-serif;
                font-size: 13px;
                box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
                width: 300px;
                overflow: hidden;
              ">
                <div style="font-size: 16px; font-weight: bold; margin-bottom: 6px; padding: 0 12px;">
                  Fecha: ${tooltip.dataPoints[0].label}
                </div>
                <div style="margin-bottom: 4px; padding: 0 12px;">Rango final: ${rankDisplay}</div>
                <div style="margin-bottom: 6px; padding: 0 12px;">Cambio: ${changeText} LP ${changeEmoji}</div>
                <div style="margin-bottom: 6px; padding: 0 12px;">Partidas: ${dayData.matches.length}</div>
            `;

            // Agregar partidas con iconos de campeones
            dayData.matches.toReversed().forEach((match: any) => {
              const championIconUrl = `https://raw.communitydragon.org/latest/plugins/rcp-be-lol-game-data/global/default/v1/champion-icons/${match.championId}.png`;
              innerHtml += `
                <div class="${match.isRemake ? "bg-neutral-900" : match.win ? "bg-green-900" : "bg-red-900"}">
                <span style="display: flex; align-items: center; padding: 6px 12px; gap: 4px;">
                  <img 
                    src="${championIconUrl}" 
                    alt="${match.champion}" 
                    style="
                      width: 24px; 
                      height: 24px; 
                      border-radius: 4px; 
                      border: 1px solid #374151;
                    "
                    onerror="this.style.display='none'"
                  />
                  <span>${match.champion}: ${match.score.kills}/${match.score.deaths}/${match.score.assists} · ${match.time}</span>
                  </span>
                </div>
              `;
            });

            innerHtml += "</div>";
            tooltipEl.querySelector("table")!.innerHTML = innerHtml;
          }
        }

        // Posicionar el tooltip de manera más simple y responsiva
        const { offsetLeft: positionX, offsetTop: positionY } = chart.canvas;
        const tooltipWidth = 300;
        const margin = 15;

        // Obtener dimensiones del contenedor del gráfico
        const chartContainer = chart.canvas.parentNode;
        const containerRect = chartContainer.getBoundingClientRect();
        const viewportWidth = window.innerWidth;

        // Calcular posición absoluta del punto en la pantalla
        const pointX = containerRect.left + tooltip.caretX;

        let leftPos, transformX;

        // Si está muy cerca del borde derecho, alinear a la izquierda del punto
        if (pointX + tooltipWidth / 2 > viewportWidth - margin) {
          leftPos = positionX + tooltip.caretX - margin;
          transformX = "-100%";
        }
        // Si está muy cerca del borde izquierdo, alinear a la derecha del punto
        else {
          leftPos = positionX + tooltip.caretX + margin;
          transformX = "0%";
        }

        // Posición vertical: siempre centrado respecto al punto
        const topPos = positionY + tooltip.caretY;
        const transformY = "-50%"; // Siempre centrado verticalmente

        // Aplicar estilos de posicionamiento mejorados
        tooltipEl.style.opacity = "1";
        tooltipEl.style.left = leftPos + "px";
        tooltipEl.style.top = topPos + "px";
        tooltipEl.style.transform = `translate(${transformX}, ${transformY})`;
        tooltipEl.style.zIndex = "9999";
        tooltipEl.style.width = "300px";
        tooltipEl.style.maxHeight = "400px";
        tooltipEl.style.overflow = "auto";
      }
    }
  },
  scales: {
    x: {
      grid: {
        color: "rgba(148, 163, 184, 0.2)",
        borderDash: [2, 2]
      },
      ticks: {
        color: "#fff",
        font: {
          size: 12
        }
      }
    },
    y: {
      min: Math.floor(visibleRange.min / 100) * 100, // Redondear al múltiplo de 100 más cercano
      max: Math.ceil(visibleRange.max / 100) * 100, // Redondear al múltiplo de 100 más cercano
      grid: {
        color: "rgba(148, 163, 184, 0.2)",
        borderDash: [2, 2]
      },
      ticks: {
        color: "#fff",
        font: {
          size: 12
        },
        callback: function (value: string | number) {
          const numValue = Number(value);
          // Solo mostrar etiquetas en valores exactos de divisiones (múltiplos de 100)
          if (numValue % 100 !== 0) return "";

          const rank = valueToRank(numValue);
          let display = rank.tier;
          if (rank.division) {
            display += ` ${rank.division}`;
          }
          return display;
        },
        // Mostrar etiquetas cada 100 puntos (cada división)
        stepSize: 100,
        maxTicksLimit: 15
      }
    }
  },
  elements: {
    line: {
      borderJoinStyle: "round" as const,
      borderCapStyle: "round" as const
    }
  }
} as const);
</script>

<template>
  <div class="chart-container">
    <Line :data="chartData" :options="chartOptions" />
  </div>
</template>

<style scoped>
.chart-container {
  position: relative;
  height: 400px;
  width: 100%;
}

@media (max-width: 768px) {
  .chart-container {
    height: 300px;
  }
}
</style>
